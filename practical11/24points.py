# -*- coding: utf-8 -*-
"""
Created on Wed May 13 19:19:23 2020

@author: 17426
"""

#The overall precedure: 
#check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#list out all kinds of arrangement of the input numbers for a specfic n
#merge the elements of every arrangement in turn until we get 24

#import python libraries
import itertools #references: https://docs.python.org/3/library/itertools.html
import fractions #references: https://docs.python.org/3/library/fractions.html
import re

m=True
s=input("Please input numbers to compute 24(use ',' to divide them):")
a=re.split(r'[\s,]+',s)   #a is a list which contains input numbers
#cheak whether the input numbers are integer and in the range of 1-23
a_int = [int(x) for x in a]
for i in a:    
    if int(i)>23 or int(i)<1 or int(i)!=float(i):
        print('The input number must be integers from 1 to 23')
        m=False
        break
a_int.sort() # List the inputted numbers in an ascending order
N=len(a_int)

def merge(a,b): 
    '''
    Compute with an operation of +,-,*,/
    The divisor cannot be zero
    '''
    if a!=0 and b!=0 and a>b:
        z=[a+b,a-b,a*b,fractions.Fraction(a,b),fractions.Fraction(b,a)] #The outcome of fractions.Fraction(m,n) is m/n,since there are cases like 7*(2+10/7)=24
    if a!=0 and b!=0 and a<=b:
        z=[a+b,b-a,a*b,fractions.Fraction(a,b),fractions.Fraction(b,a)] 
    if a==0 and b!=0:
        z=[b,0]
    if a!=0 and b==0:
        z=[a,0]
    if a==0 and b==0:
        z=[0]
    return z

def enumerat(i):
    '''
    For a given order of numbers, all possible operations are performed
    The function returns the operation results (merged)
    '''
    sequence = list(all_sequence[i]) # the all_sequence generated by itertools is tuple, so convert tuple into list
    x = merge(sequence[0],sequence[1])
    del sequence[0:2] # Delete the two numbers
    while sequence!=[]: # Repeat it until every number in 'sequence' is deleted (used in the 'computed' function.)
        x1 = x # temperarily store x
        x=[]
        for j in x1:
            x += merge(j,sequence[0]) # Store the new results of y
        del sequence[0] # Delete the number in 'sequence' used in the 'compute' function
    return x


list1_time = 0
recursion_time = 0
if m==True:
 for i in range(N,1,-1):  #Complexity estimation: the first loop      
    all_sequence = list(itertools.permutations(a_int, i)) #generate i-length tuples, all possible orderings
    list1 = []
    #Complexity estimation: the second loop
    for i in range(0, len(all_sequence)): #repeat 'enumeration' for every order of inputted numbers
      if m==True:
        list1 += enumerat(i)    # Complexity estimation: the third loop (in the enumerat function)
        list1_time = len(list1) # The exact recursion time in this enumeration (The recursion time is bit higher since the merge is not immediately stopped after we get 24)
        if 24 in list1: # When the right outcome 24 is found, exit the program and output the recursion time.
            print('Yes')
            print('recursion times: '+ str(recursion_time + list1_time) + '\n') # The exact recursion time = recursion time of last for-loop + the exact list1_time
            m=False  #label whether we need to continue merging and searching or not
        recursion_time += len(list1) # Record the exact whole recursion time 
if m==True: print('No'+'\n'+'recursion times: '+ str(recursion_time)) # When there is no outcome of 24, output the failed message. 

#explaination about the recursive time
#note that the code check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#for example, 2,12,1,1,1,1,1 recursive time is quite big. Although it looks easy (2*12=24), but the code first check whether we can use all the numbers (2*12*/1*/1*/1*/1*/1) to get 24. 
#anather example: 10,10,4,4 recursive time is also quite big. Athough it looks easy (10+10+4=24), but the code first check whether we can use all the numbers (10*10-4)/4)

#Complexity estimation:
#The first loop (for i in range(N,1,-1)) is to check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#
#The second loop (for i in range(0, len(all_sequence)) is to repeat 'enumeration' for every order of inputted numbers. 
#if we use all numbers, the number of the possible sequences are N!
#if we use N-1 numbers, the number of the possible sequences are still N!
#if we use N-2 numbers, the number of the possible sequences are (CN2)(N-2)!
#In conclusion, if we use n numbers, the number of the possible sequences are (CNn)(N-n)!
#O((CNn)(N-n)!)=O(N!/n!)
#
#The third loop is all possible sequences undergo merge process. All these terms need to be multipied by n-1. 
#O(n-1)
#So we get (n-1)(N!/n!) for every n. 
#To sum up, the complexity is (N-1)N!+(N-2)N!/2!+'''+2*N!/(N-1)!+1. 