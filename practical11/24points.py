# -*- coding: utf-8 -*-
"""
Created on Wed May 13 19:19:23 2020

@author: 17426
"""

#The overall precedure: 
#check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#list out all kinds of arrangement of the input numbers for a specfic n
#merge the elements of every arrangement in turn until we get 24

#import python libraries
import itertools
import fractions #The outcome of fractions.Fraction(m,n) is m/n,since there are cases like 7*(2+10/7)=24
import re

m=True
s=input("Please input numbers to compute 24:(use ',' to divide them)")
a=re.split(r'[\s,]+',s)   #a is a list which contains input numbers
#cheak whether the input numbers are integer and in the range of 1-23
a_int = [int(x) for x in a]
for i in a:    
    if int(i)>23 or int(i)<1 or int(i)!=float(i):
        print('The input number must be integers from 1 to 23')
        m=False
        break
a_int.sort() # List the inputted numbers in an ascending order
N=len(a_int)

def merge(a,b): 
    '''
    Compute with an operation of +,-,*,/
    The divisor cannot be zero
    '''
    if a!=0 and b!=0:
        z=[a+b,b-a,a*b,fractions.Fraction(a,b),fractions.Fraction(b,a)] 
    if a==0 and b!=0:
        z=[a+b,b-a,a*b,fractions.Fraction(a,b)]
    if a!=0 and b==0:
        z=[a+b,b-a,a*b,fractions.Fraction(b,a)]
    if a==0 and b==0:
        z=[a+b,b-a,a*b]
    return z

def enumerate(i):
    '''
    For a given order of numbers, all possible operations are performed
    The function returns the operation results (merged)
    '''
    sequence = list(all_sequence[i]) # the all_sequence generated by itertools is tuple, so convert tuple into list
    x = merge(sequence[0],sequence[1])
    del sequence[0:2] # Delete the two numbers
    while sequence!=[]: # Repeat it until every number in 'sequence' is deleted (used in the 'computed' function.)
        x1 = x # temperarily store x
        x=[]
        for j in x1:
            x += merge(j,sequence[0]) # Store the new results of y
        del sequence[0] # Delete the number in 'sequence' used in the 'compute' function
    return x


list1_time = 0
recursion_time = 0
if m==True:
 for i in range(N,1,-1):        
    all_sequence = list(itertools.permutations(a_int, i)) #Permutation
    list1 = []
    for i in range(0, len(all_sequence)): #repeat 'enumeration' for every order of inputted numbers
      if m==True:
        list1 += enumerate(i)
        list1_time = len(list1) # The exact recursion time in this enumeration (The recursion time is bit higher since the merge is not immediately stopped after we get 24)
        if 24 in list1: # When the right outcome 24 is found, exit the program and output the exact recursion time.
            print('Yes')
            print('recursion times: '+ str(recursion_time + list1_time) + '\n') # The exact recursion time = recursion time of last for-loop + the exact list1_time
            m=False
        recursion_time += len(list1) # Record the exact whole recursion time 
if m==True: print('No\nrecursion times: '+ str(recursion_time)) # When there is no outcome of 24, output the failed message. 

#explaination about the recursive time
#note that the code check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#for example, 2,12,1,1,1,1,1 recursive time is quite big. Although it looks easy (2*12=24), but the code first check whether we can use all the numbers (2*12*/1*/1*/1*/1*/1) to get 24. 

#Complexity estimation:
#The first loop (for i in range(N,1,-1)) is to code check whether we can use all input numbers (n) to get 24, and then n-1 numbers and then n-2 and so on. 
#O(N-1) (N is the number of cards)
#The second loop (for i in range(0, len(all_sequence)) is to merge every possible sequences. 
#if we use all numbers, the number of the possible sequences are N!
#if we use N-1 numbers, the number of the possible sequences are still N!
#if we use N-2 numbers, the number of the possible sequences are (CN2)(N-2)!
#In conclusion, if we use n numbers, the number of the possible sequences are (CNn)(N-n)!
#And then all possible sequences need to undergo merge process. All these terms need to be multipied by n-1. 
#So we get (n-1)(CNn)((N-n)!). Keep the dominant terms, we get N!/n!
#To sum up, the complexity is N!+N!/2!+'''+N!/(N-1)!+1. 